//+------------------------------------------------------------------+
//| TVLucroGrid EA v1.0 - Grid Strategy with Profit Target           |
//| Expert Advisor that opens orders every 5 seconds until $100 target |
//| Compatible with existing webhook receiver                           |
//+------------------------------------------------------------------+
#property copyright "TVLucroGrid Automation"
#property link      "https://github.com"
#property version   "1.0"
#property strict

#include <Trade\Trade.mqh>
#include <Trade\SymbolInfo.mqh>
#include <Trade\PositionInfo.mqh>

//--- Input Parameters - Basic Settings
input string   TradingSymbol = "XAUUSD";         // Symbol to trade
input int      MagicNumber = 54321;           // Magic number (different from tvlucro)
input double   RiskPercent = 1.0;             // % of equity per order
input bool     UseFixedLots = true;           // Use fixed lots instead of risk % - CHANGED TO TRUE
input double   FixedLotSize = 0.01;           // Fixed lot size (if UseFixedLots=true)
input bool     ValidateLotSize = true;        // Validate broker lot limits
input int      TakeProfitPoints = 1000;        // TP in points (e.g., 1000 = $10 for XAUUSD)
input int      StopLossPoints = 500;           // SL in points (e.g., 500 = $5 for XAUUSD)

//--- Grid Settings
input int      PollingIntervalSec = 1;        // Signal polling frequency (seconds)
input string   SignalFilePath = "signal_XAUUSD.json"; // Signal file path (works for both XAUUSD and XAUUSDc)
input int      GridIntervalSeconds = 5;       // Interval between grid orders (seconds)
input double   ProfitTargetMoney = 100.0;     // Total profit target ($)
input int      MaxGridOrders = 20;            // Maximum orders per direction
input bool     CloseAllOnTarget = true;        // Close all when target reached

//--- Reversal Settings
input bool     EnableAutoReverse = true;       // Enable automatic reversal
input double   MinProfitToReverse = 50.0;     // Minimum profit to consider reversal ($)
input bool     RequireOppositeSignal = true;   // Require opposite signal to reverse
input int      ReversalConfirmationCandles = 3; // Confirmation candles

//--- Trend Detection
input bool     EnableTrendDetection = true;    // Enable trend-based reversal
input int      TrendCheckCandles = 3;          // Number of candles to check for trend
input bool     RequireConsecutiveCandles = true; // All candles must be in same direction
input int      AgainstTrendThreshold = 2;      // Stop adding if X candles against current position
input bool     ReverseOnTrendRegardlessProfit = false; // Reverse on trend even WITHOUT minimum profit

//--- Hedge Strategy (NEVER closes in loss, always waits for profit)
input bool     EnableHedgeMode = true;         // Enable hedge mode (opens new direction without closing old)
input double   HedgeProfitTarget = 30.0;       // Close ALL when total profit reaches this amount ($)
input int      MaxHedgeDurationMinutes = 60;    // Maximum time in hedge mode before forced close (0 = no limit)
input bool     CloseHedgeOnBreakeven = true;    // Close all positions if total profit >= 0 while in hedge

//--- Debug & Testing
input bool     ForceResetOnNewSignal = false;  // Force reset state when ANY new signal arrives (ignore lastProcessed) - WARNING: Can close losing positions!

//--- Protection
input double   MaxDrawdownPercent = 10.0;     // Maximum drawdown (% of equity)
input double   MaxLossPerOrder = 20.0;         // Maximum loss per order ($)
input bool     EnableEmergencyClose = true;    // Emergency close all

//--- Trailing Stop
input bool     EnableTrailingStop = true;      // Enable trailing stop for profitable positions
input int      TrailingStartPoints = 200;      // Start trailing after X points profit
input int      TrailingStopPoints = 100;       // Trailing stop distance in points
input int      TrailingStepPoints = 50;        // Move SL every X points

//--- Visual Panel
input bool     ShowInfoPanel = true;           // Show info panel
input int      PanelX = 20;
input int      PanelY = 50;
input int      PanelWidth = 220;

//--- Global Variables - Grid State
string activeSymbol = "";              // Active symbol (from chart, auto-detects XAUUSD/XAUUSDc)
string currentDirection = "";          // Current direction: "buy" or "sell"
datetime lastGridOrderTime = 0;        // Last grid order timestamp
int currentGridLevel = 0;              // Current grid level (order count)
bool targetReached = false;            // If $100 target was reached

//--- Hedge State
bool inHedgeMode = false;              // If currently in hedge mode (both directions open)
string hedgeOldDirection = "";         // The old direction before hedge
datetime hedgeStartTime = 0;           // When hedge mode started
int hedgeNewLevel = 0;                 // Grid level in NEW direction (hedge orders)

//--- Signal Control
string lastProcessedJson = "";         // Last processed JSON
datetime lastSignalTime = 0;           // Last signal timestamp
string pendingDirection = "";          // Pending direction for reversal
datetime lastSignalProcessedTime = 0;  // When last signal was processed (for cooldown)

//--- Statistics
int totalOrdersOpened = 0;            // Total orders opened in session
double maxProfitReached = 0;          // Maximum profit reached
double maxDrawdownReached = 0;        // Maximum drawdown reached

//--- Trade Objects
CTrade trade;
CSymbolInfo symbolInfo;
CPositionInfo positionInfo;

//--- Panel Variables - DISABLED
//string panelPrefix = "TVGridPanel_";
//bool panelInitialized = false;
//datetime lastPanelUpdate = 0;
//int PanelUpdateInterval = 1;

//+------------------------------------------------------------------+
//| Expert initialization function                                       |
//+------------------------------------------------------------------+
int OnInit()
{
    // Initialize trade objects
    trade.SetExpertMagicNumber(MagicNumber);
    trade.SetDeviationInPoints(10);
    trade.SetTypeFilling(ORDER_FILLING_IOC);

    // Use the symbol from the current chart (auto-detects XAUUSD or XAUUSDc)
    activeSymbol = _Symbol;
    symbolInfo.Name(activeSymbol);

    Print("=== TVLucroGrid EA v1.0 Started ===");
    Print("Chart Symbol: ", activeSymbol, " (configured: ", TradingSymbol, ")");
    Print("Magic Number: ", MagicNumber);
    Print("Grid Interval: ", GridIntervalSeconds, " seconds");
    Print("Profit Target: $", ProfitTargetMoney);
    Print("Max Grid Orders: ", MaxGridOrders);

    // Verify symbol info is valid
    if (!symbolInfo.RefreshRates())
    {
        Print("ERROR: Failed to refresh symbol rates for ", activeSymbol);
        return(INIT_FAILED);
    }

    Print("Symbol Info Valid: Ask=", symbolInfo.Ask(), " Bid=", symbolInfo.Bid());

    // Initialize panel
    //if (ShowInfoPanel)
    //{
    //    CreateInfoPanel();
    //}

    // Set up timer for main loop
    if (!EventSetTimer(PollingIntervalSec))
    {
        Print("ERROR: Failed to set timer!");
        return(INIT_FAILED);
    }

    Print("Timer configured: ", PollingIntervalSec, " second(s)");
    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                     |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
    // Kill timer
    EventKillTimer();

    // Clean up panel
    //if (ShowInfoPanel)
    //{
    //    DeleteInfoPanel();
    //}

    Print("=== TVLucroGrid EA v1.0 Stopped ===");
    Print("Reason: ", reason);
}

//+------------------------------------------------------------------+
//| Timer function - Main loop                                        |
//+------------------------------------------------------------------+
void OnTimer()
{
    // HEARTBEAT: Show EA is running every 30 seconds
    static datetime lastHeartbeat = 0;
    datetime currentTime = TimeCurrent();
    if (currentTime - lastHeartbeat >= 30)
    {
        Print("=== HEARTBEAT === EA is running | Current Direction: ", currentDirection, " | Hedge: ", inHedgeMode ? "YES" : "NO");
        lastHeartbeat = currentTime;
    }

    // Update panel
    //if (ShowInfoPanel)
    //{
    //    UpdateInfoPanel();
    //}

    // 1. Read signal file
    string jsonContent = ReadSignalFile();

    // Debug: Log file reading every 10 seconds
    static datetime lastDebugLog = 0;
    if (currentTime - lastDebugLog >= 10)
    {
        if (jsonContent == "")
            Print("DEBUG: No signal file found or empty file");
        else if (jsonContent == lastProcessedJson)
            Print("DEBUG: Signal file unchanged (waiting for new signal)");
        else
            Print("DEBUG: New signal detected in file!");
        lastDebugLog = currentTime;
    }

    // 2. Check if signal changed
    bool isNewSignal = (jsonContent != "" && jsonContent != lastProcessedJson);

    if (isNewSignal || (ForceResetOnNewSignal && jsonContent != ""))
    {
        Print("================================================================================");
        Print("=== NEW SIGNAL DETECTED ===");
        Print("DEBUG: Raw JSON content: '", jsonContent, "'");
        Print("DEBUG: Last processed: '", lastProcessedJson, "'");
        Print("DEBUG: ForceResetOnNewSignal: ", ForceResetOnNewSignal ? "YES" : "NO");

        // 2.1. Extract and validate symbol
        string signalSymbol = ExtractSymbolFromJSON(jsonContent);
        Print("DEBUG: Extracted symbol: '", signalSymbol, "' Configured: '", TradingSymbol, "'");

        if (!IsSignalForThisSymbol(signalSymbol))
        {
            Print("DEBUG: Signal IGNORED - Symbol mismatch");
            lastProcessedJson = jsonContent;
            return;
        }

        string signalDirection = ExtractDirectionFromJSON(jsonContent);
        Print("DEBUG: Extracted direction: '", signalDirection, "'");

        // CRITICAL: Show what direction was extracted
        if (signalDirection == "buy")
            Print(">>> DIRECTION CONFIRMED: BUY (will open BUY orders) <<<");
        else if (signalDirection == "sell")
            Print(">>> DIRECTION CONFIRMED: SELL (will open SELL orders) <<<");
        else
            Print(">>> ERROR: Invalid direction extracted: '", signalDirection, "' <<<");

        if (signalDirection != "")
        {
            Print("=== SIGNAL RECEIVED ===");
            Print("Signal Direction: ", signalDirection);
            Print("Current Direction: ", currentDirection);
            Print("Hedge Mode: ", inHedgeMode ? "YES" : "NO");
            Print("Positions: ", PositionsTotal());
            lastSignalTime = TimeCurrent();

            // FORCE RESET MODE: Close everything and start fresh with new signal
            if (ForceResetOnNewSignal && isNewSignal)
            {
                Print("=== FORCE RESET MODE ===");
                Print("WARNING: ForceResetOnNewSignal is enabled!");

                // CRITICAL: Check for losing positions BEFORE closing
                int losingPositions = 0;
                int totalPositions = 0;
                double totalUnrealizedPL = 0;

                for (int i = PositionsTotal() - 1; i >= 0; i--)
                {
                    if (positionInfo.SelectByIndex(i))
                    {
                        if (positionInfo.Symbol() == activeSymbol &&
                            positionInfo.Magic() == MagicNumber)
                        {
                            totalPositions++;
                            totalUnrealizedPL += positionInfo.Profit();
                            if (positionInfo.Profit() < 0)
                            {
                                losingPositions++;
                            }
                        }
                    }
                }

                // If there are losing positions, WARNING but still close (user explicitly enabled ForceReset)
                if (losingPositions > 0)
                {
                    Print("================================================================================");
                    Print("DANGER: ForceResetOnNewSignal will CLOSE ", losingPositions, " LOSING positions!");
                    Print("Total P&L to be realized: $", totalUnrealizedPL);
                    Print("This will LOCK IN LOSSES! Consider using hedge mode instead.");
                    Print("To disable this behavior, set ForceResetOnNewSignal = false");
                    Print("================================================================================");
                    Sleep(5000);  // 5 second warning to allow user to intervene
                }

                Print("Closing all positions and starting fresh with signal: ", signalDirection);

                // Close all positions first
                if (PositionsTotal() > 0)
                {
                    CloseAllPositions();
                    Sleep(1000);
                }

                // Reset all state
                ResetGridState();

                // Open first order in new signal direction
                Print(">>> OPENING FIRST ORDER: ", signalDirection);
                if (ExecuteGridOrder(signalDirection))
                {
                    currentDirection = signalDirection;
                    lastProcessedJson = jsonContent;
                    Print("Grid started with direction: ", currentDirection);
                }
                return;
            }

            // NORMAL MODE: Handle based on current state
            // 3. If no direction (first signal)
            if (currentDirection == "" && !inHedgeMode)
            {
                Print(">>> FIRST SIGNAL - Opening in direction: ", signalDirection);

                if (ExecuteGridOrder(signalDirection))
                {
                    currentDirection = signalDirection;
                    lastProcessedJson = jsonContent;
                    lastSignalProcessedTime = TimeCurrent();  // Set cooldown timestamp
                    Print("Grid started. Direction: ", currentDirection);
                    Print("Signal cooldown active for 60 seconds - trend reversal blocked");
                }
            }
            // 4. Already have direction - check for reversal
            else
            {
                Print("Already trading. Current: ", currentDirection, " Signal: ", signalDirection);

                // Check if signal is opposite direction
                bool isOppositeSignal = (signalDirection != currentDirection);

                Print("REVERSAL CHECK: Current=", currentDirection, " Signal=", signalDirection, " IsOpposite=", isOppositeSignal, " EnableAutoReverse=", EnableAutoReverse);

                if (isOppositeSignal && EnableAutoReverse)
                {
                    // Check for losing positions - if yes, use HEDGE mode
                    int losingPositions = 0;
                    int totalPositions = 0;
                    double totalUnrealizedPL = 0;

                    for (int i = PositionsTotal() - 1; i >= 0; i--)
                    {
                        if (positionInfo.SelectByIndex(i))
                        {
                            if (positionInfo.Symbol() == activeSymbol &&
                                positionInfo.Magic() == MagicNumber)
                            {
                                totalPositions++;
                                totalUnrealizedPL += positionInfo.Profit();
                                if (positionInfo.Profit() < 0)
                                {
                                    losingPositions++;
                                }
                            }
                        }
                    }

                    double accountProfit = AccountInfoDouble(ACCOUNT_PROFIT);

                    // If has losing positions and hedge enabled, enter HEDGE mode
                    if (losingPositions > 0 && EnableHedgeMode && !inHedgeMode)
                    {
                        Print("=== ENTERING HEDGE MODE (WEBHOOK) ===");
                        Print("Opposite signal received but has ", losingPositions, " losing positions");
                        Print("Old Direction: ", currentDirection, " | New Direction: ", signalDirection);
                        Print("Current Profit: $", accountProfit);
                        Print("Opening NEW direction positions WITHOUT closing old ones");

                        // Set hedge state
                        hedgeOldDirection = currentDirection;
                        hedgeStartTime = TimeCurrent();
                        hedgeNewLevel = 0;
                        inHedgeMode = true;

                        // Update current direction to NEW direction (for new orders)
                        currentDirection = signalDirection;

                        // Open first order in NEW direction
                        if (ExecuteGridOrder(currentDirection))
                        {
                            Print("HEDGE MODE ACTIVATED (webhook)");
                            Print("Old positions remain open. Adding positions in ", currentDirection);
                            Print("Will exit hedge when profit >= $", HedgeProfitTarget);
                            lastSignalProcessedTime = TimeCurrent();  // Set cooldown
                        }

                        lastProcessedJson = jsonContent;
                        return;
                    }

                    // If all positions profitable OR hedge disabled, do normal reversal
                    if (ShouldReverseDirection(signalDirection))
                    {
                        Print("=== REVERSAL TRIGGERED ===");
                        Print("Closing all and reversing to: ", signalDirection);

                        if (CloseAllPositions())
                        {
                            Sleep(1000);

                            if (ExecuteGridOrder(signalDirection))
                            {
                                currentDirection = signalDirection;
                                targetReached = false;
                                lastProcessedJson = jsonContent;
                                lastSignalProcessedTime = TimeCurrent();  // Set cooldown
                                Print("Reversal complete. New direction: ", currentDirection);
                            }
                        }
                    }
                    else
                    {
                        Print("Signal ignored - reversal conditions not met");
                        lastProcessedJson = jsonContent;
                    }
                }
                else
                {
                    Print("Signal ignored - same direction or auto-reverse disabled");
                    lastProcessedJson = jsonContent;
                }
            }
        }
    }

    // 5. If we have a direction, manage grid
    if (currentDirection != "")
    {
        // 5.0 Check if we still have positions - if not, reset grid state
        int positionCount = 0;
        for (int i = PositionsTotal() - 1; i >= 0; i--)
        {
            if (positionInfo.SelectByIndex(i))
            {
                if (positionInfo.Symbol() == activeSymbol &&
                    positionInfo.Magic() == MagicNumber)
                {
                    positionCount++;
                }
            }
        }

        // Update currentGridLevel to match actual position count
        if (currentGridLevel != positionCount)
        {
            currentGridLevel = positionCount;
        }

        // If no positions but we think we have a direction, reset
        if (positionCount == 0 && currentDirection != "")
        {
            Print("=== NO POSITIONS FOUND ===");
            Print("Grid state reset. Waiting for new signal.");
            ResetGridState();
            return;
        }

        double accountProfit = AccountInfoDouble(ACCOUNT_PROFIT);

        // 5.05 HEDGE MODE: Check if we should exit hedge mode with profit
        if (inHedgeMode)
        {
            Print("=== HEDGE MODE ACTIVE ===");
            Print("Old Direction: ", hedgeOldDirection, " | New Direction: ", currentDirection);
            Print("Old Level: ", currentGridLevel, " | New Level: ", hedgeNewLevel);
            Print("Total Profit: $", accountProfit);

            bool shouldExitHedge = false;
            string exitReason = "";

            // Exit hedge if profit target reached
            if (accountProfit >= HedgeProfitTarget)
            {
                shouldExitHedge = true;
                exitReason = "Hedge profit target reached";
            }
            // Exit hedge if breakeven and enabled
            else if (CloseHedgeOnBreakeven && accountProfit >= 0)
            {
                shouldExitHedge = true;
                exitReason = "Hedge breakeven reached";
            }
            // Exit hedge if max duration exceeded
            else if (MaxHedgeDurationMinutes > 0)
            {
                int minutesInHedge = (int)((TimeCurrent() - hedgeStartTime) / 60);
                if (minutesInHedge >= MaxHedgeDurationMinutes)
                {
                    shouldExitHedge = true;
                    exitReason = "Max hedge duration exceeded (" + IntegerToString(minutesInHedge) + " minutes)";
                }
            }

            if (shouldExitHedge)
            {
                Print("=== EXITING HEDGE MODE ===");
                Print("Reason: ", exitReason);
                Print("Closing ALL positions with profit: $", accountProfit);

                if (CloseAllPositions())
                {
                    Sleep(1000);
                    ResetGridState();
                    // Don't open new orders - wait for fresh signal
                    Print("Hedge closed. Waiting for new signal.");
                    return;
                }
            }
        }

        // 5.1 Check if target reached (skip main target if in hedge mode)
        if (!inHedgeMode && accountProfit >= ProfitTargetMoney)
        {
            Print("=== TARGET REACHED ===");
            Print("Profit: $", accountProfit, " Target: $", ProfitTargetMoney);

            if (CloseAllOnTarget)
            {
                CloseAllPositions();
                ResetGridState();
                Print("All positions closed. Grid reset.");
            }

            return;
        }

        // 5.2 Check if should add grid order
        if (ShouldAddGridOrder())
        {
            Print("=== ADDING GRID ORDER ===");
            Print("Current Level: ", currentGridLevel, " Direction: ", currentDirection);

            if (ExecuteGridOrder(currentDirection))
            {
                Print("Grid order added. New level: ", currentGridLevel);
            }
        }

        // 5.3 Check stop loss for individual positions
        CheckStopLoss();

        // 5.4 Manage trailing stop for profitable positions
        ManageTrailingStop();

        // 5.5 Check for trend-based reversal (automatic, no signal needed)
        if (!inHedgeMode && EnableAutoReverse && EnableTrendDetection && currentDirection != "")
        {
            // DEBUG: Show trend check is happening
            static datetime lastTrendDebug = 0;
            if (TimeCurrent() - lastTrendDebug >= 5)
            {
                Print("=== TREND CHECK === Current: ", currentDirection, " EnableTrendDetection: ", EnableTrendDetection);
                lastTrendDebug = TimeCurrent();
            }

            // CRITICAL: Check if we're in cooldown period after a signal
            // Don't reverse by trend for 60 seconds after processing a signal
            int secondsSinceSignal = (int)(TimeCurrent() - lastSignalProcessedTime);
            if (secondsSinceSignal < 60 && lastSignalProcessedTime > 0)
            {
                static datetime lastCooldownLog = 0;
                if (TimeCurrent() - lastCooldownLog >= 10)  // Log every 10 seconds
                {
                    Print("TREND REVERSAL BLOCKED: Signal cooldown active (", secondsSinceSignal, "/60s)");
                    lastCooldownLog = TimeCurrent();
                }
            }
            else
            {
                string oppositeDirection = (currentDirection == "buy") ? "sell" : "buy";
                double accountProfit = AccountInfoDouble(ACCOUNT_PROFIT);

                // Check if trend is confirmed (opposite direction)
                bool trendConfirmed = IsTrendConfirmedByCandles(oppositeDirection, TrendCheckCandles);

                Print("TREND CHECK: Opposite=", oppositeDirection, " Confirmed=", trendConfirmed,
                      " Profit=$", accountProfit, " MinProfit=$", MinProfitToReverse);

            if (trendConfirmed)
            {
                // Check profit requirement
                bool hasEnoughProfit = (accountProfit >= MinProfitToReverse);
                bool canReverseRegardless = ReverseOnTrendRegardlessProfit;

                Print("PROFIT CHECK: hasEnoughProfit=", hasEnoughProfit, " canReverseRegardless=", canReverseRegardless);

                if (!hasEnoughProfit && !canReverseRegardless)
                {
                    Print("BLOCK: Trend confirmed but NOT ENOUGH PROFIT (need $", MinProfitToReverse, ", have $", accountProfit, ")");
                }
                else
                {
                    // Check for losing positions - decide between HEDGE and REVERSE
                    int losingPositions = 0;
                    int totalPositions = 0;
                    double totalUnrealizedPL = 0;

                    for (int i = PositionsTotal() - 1; i >= 0; i--)
                    {
                        if (positionInfo.SelectByIndex(i))
                        {
                            if (positionInfo.Symbol() == activeSymbol &&
                                positionInfo.Magic() == MagicNumber)
                            {
                                totalPositions++;
                                totalUnrealizedPL += positionInfo.Profit();
                                if (positionInfo.Profit() < 0)
                                {
                                    losingPositions++;
                                }
                            }
                        }
                    }

                    // If has losing positions and hedge enabled, enter HEDGE mode
                    if (losingPositions > 0 && EnableHedgeMode && !inHedgeMode)
                    {
                        // ENTER HEDGE MODE - Don't close old positions, just add new direction
                        Print("=== ENTERING HEDGE MODE (TREND) ===");
                        Print("Trend changed but has ", losingPositions, " losing positions");
                        Print("Old Direction: ", currentDirection, " | New Direction: ", oppositeDirection);
                        Print("Current Profit: $", accountProfit);
                        Print("Opening NEW direction positions WITHOUT closing old ones");

                        // Set hedge state
                        hedgeOldDirection = currentDirection;
                        hedgeStartTime = TimeCurrent();
                        hedgeNewLevel = 0;
                        inHedgeMode = true;

                        // Update current direction to NEW direction (for new orders)
                        currentDirection = oppositeDirection;

                        // Open first order in NEW direction
                        if (ExecuteGridOrder(currentDirection))
                        {
                            Print("HEDGE MODE ACTIVATED (trend-based)");
                            Print("Old positions remain open. Adding positions in ", currentDirection);
                            Print("Will exit hedge when profit >= $", HedgeProfitTarget);
                        }
                    }
                    else if (losingPositions == 0)
                    {
                        // All positions profitable - close all and reverse
                        Print("=== AUTOMATIC REVERSAL (TREND-BASED) ===");
                        Print("All ", totalPositions, " positions profitable");
                        Print("Closing all positions and reversing to ", oppositeDirection);

                        if (CloseAllPositions())
                        {
                            Sleep(1000);

                            if (ExecuteGridOrder(oppositeDirection))
                            {
                                currentDirection = oppositeDirection;
                                targetReached = false;
                                Print("Trend-based reversal complete. New direction: ", currentDirection);
                            }
                        }
                    }
                    else
                    {
                        Print("TREND REVERSAL BLOCKED: Has ", losingPositions, " losing positions");
                        Print("EnableHedgeMode is OFF - set to true to allow hedge");
                    }
                }
            }  // Close else block (after cooldown check)
        }
    }
}

//+------------------------------------------------------------------+
//| Read signal file from Common Files directory                        |
//+------------------------------------------------------------------+
string ReadSignalFile()
{
    int fileHandle = FileOpen(SignalFilePath, FILE_READ|FILE_TXT|FILE_ANSI|FILE_COMMON|FILE_SHARE_READ|FILE_SHARE_WRITE);

    if (fileHandle == INVALID_HANDLE)
    {
        // File doesn't exist yet - not an error
        static datetime lastFileErrorLog = 0;
        if (TimeCurrent() - lastFileErrorLog >= 30)
        {
            Print("DEBUG: Cannot open signal file: ", SignalFilePath);
            lastFileErrorLog = TimeCurrent();
        }
        return "";
    }

    // Read entire file line by line
    string content = "";
    while (!FileIsEnding(fileHandle))
    {
        content += FileReadString(fileHandle);
    }

    Print("DEBUG: File ", SignalFilePath, " read, content length: ", StringLen(content), " chars");

    FileClose(fileHandle);
    return content;
}

//+------------------------------------------------------------------+
//| Extract symbol from JSON signal                                   |
//+------------------------------------------------------------------+
string ExtractSymbolFromJSON(string json)
{
    // Function body - extract symbol from JSON
    string symbolKey = "\"symbol\":";
    int keyPos = StringFind(json, symbolKey);

    if (keyPos == -1)
    {
        return "";
    }

    int valueStart = keyPos + StringLen(symbolKey);

    // Skip whitespace
    while (valueStart < StringLen(json) &&
           (StringGetCharacter(json, valueStart) == ' ' ||
            StringGetCharacter(json, valueStart) == '\t'))
    {
        valueStart++;
    }

    // Check if it's a string
    if (StringGetCharacter(json, valueStart) != '"')
    {
        return "";
    }

    valueStart++;  // Skip opening quote

    // Find closing quote
    int valueEnd = valueStart;
    while (valueEnd < StringLen(json) &&
           StringGetCharacter(json, valueEnd) != '"' &&
           StringGetCharacter(json, valueEnd) != '}' &&
           StringGetCharacter(json, valueEnd) != ',')
    {
        valueEnd++;
    }

    string symbol = StringSubstr(json, valueStart, valueEnd - valueStart);
    return symbol;
}

//+------------------------------------------------------------------+
//| Check if signal is for this EA's symbol                               |
//+------------------------------------------------------------------+
bool IsSignalForThisSymbol(string signalSymbol)
{
    // If signal has no symbol field, accept it (backward compatibility)
    if (signalSymbol == "")
        return true;

    // Helper function to remove 'c' suffix for symbol comparison
    string NormalizeSymbol(string sym)
    {
        string result = sym;
        // Remove trailing 'c' if present (XAUUSDc -> XAUUSD)
        if (StringLen(result) > 0 && StringGetCharacter(result, StringLen(result) - 1) == 'c')
        {
            result = StringSubstr(result, 0, StringLen(result) - 1);
        }
        return result;
    }

    string normalizedSignal = NormalizeSymbol(signalSymbol);
    string normalizedTrading = NormalizeSymbol(TradingSymbol);

    // Compare normalized symbols
    int result = StringCompare(normalizedSignal, normalizedTrading);
    if (result == 0)
    {
        return true;
    }

    Print("Signal IGNORED - Symbol mismatch: '", signalSymbol, "' != '", TradingSymbol, "'");
    return false;
}

//+------------------------------------------------------------------+
//| Extract direction from JSON                                         |
//+------------------------------------------------------------------+
string ExtractDirectionFromJSON(string jsonContent)
{
    string direction = "";

    // Try to find "action" field first (legacy format)
    int actionPos = StringFind(jsonContent, "\"action\"");
    Print("DEBUG: actionPos = ", actionPos);

    if (actionPos >= 0)
    {
        int colonPos = StringFind(jsonContent, ":", actionPos);
        Print("DEBUG: colonPos = ", colonPos);

        if (colonPos > 0)
        {
            // Find the opening quote after the colon (skip whitespace)
            int quoteStart = StringFind(jsonContent, "\"", colonPos);
            Print("DEBUG: quoteStart = ", quoteStart);

            if (quoteStart > 0)
            {
                // Find the closing quote
                int quoteEnd = StringFind(jsonContent, "\"", quoteStart + 1);
                Print("DEBUG: quoteEnd = ", quoteEnd);

                if (quoteEnd > 0)
                {
                    string actionValue = StringSubstr(jsonContent, quoteStart + 1, quoteEnd - quoteStart - 1);
                    Print("DEBUG: actionValue raw = '", actionValue, "'");

                    actionValue = StringToLower(actionValue);
                    Print("DEBUG: actionValue lower = '", actionValue, "'");

                    // Convert to buy/sell
                    if (actionValue == "long" || actionValue == "buy")
                        direction = "buy";
                    else if (actionValue == "short" || actionValue == "sell")
                        direction = "sell";

                    Print("DEBUG: Final direction = '", direction, "'");
                }
            }
        }
    }

    return direction;
}

//+------------------------------------------------------------------+
//| Check if should add grid order                                     |
//+------------------------------------------------------------------+
bool ShouldAddGridOrder()
{
    // Check interval
    if (TimeCurrent() - lastGridOrderTime < GridIntervalSeconds)
        return false;

    // In hedge mode, check NEW direction level; otherwise check total level
    int ordersToAdd = inHedgeMode ? hedgeNewLevel : currentGridLevel;

    // Check max orders
    if (ordersToAdd >= MaxGridOrders)
    {
        Print("Max grid orders reached: ", MaxGridOrders, " (Hedge mode: ", inHedgeMode, ")");
        return false;
    }

    // Check drawdown limit
    double accountProfit = AccountInfoDouble(ACCOUNT_PROFIT);
    double equity = AccountInfoDouble(ACCOUNT_EQUITY);
    double maxLoss = equity * (MaxDrawdownPercent / 100.0);

    if (accountProfit < -maxLoss)
    {
        Print("Drawdown limit reached: $", accountProfit, " Max loss: $", -maxLoss);
        return false;
    }

    // Check if candles are going AGAINST current position (trend reversal)
    // Skip this check in hedge mode - we already know candles are against old direction
    if (!inHedgeMode && EnableTrendDetection && AreCandlesAgainstPosition(AgainstTrendThreshold))
    {
        Print("=== TREND REVERSAL DETECTED ===");
        Print("Candles are going against ", currentDirection, " position");
        Print("Stopping grid addition - waiting for reversal signal");
        return false;
    }

    return true;
}

//+------------------------------------------------------------------+
//| Count bullish candles in last N candles                             |
//+------------------------------------------------------------------+
int CountBullishCandles(int count, ENUM_TIMEFRAMES timeframe = PERIOD_M1)
{
    int bullish = 0;
    for (int i = 0; i < count; i++)
    {
        int shift = i + 1;  // 1 = most recent completed candle
        double open = iOpen(activeSymbol, timeframe, shift);
        double close = iClose(activeSymbol, timeframe, shift);
        if (close > open)
            bullish++;
    }
    static datetime lastCandleLog = 0;
    if (TimeCurrent() - lastCandleLog >= 5)
    {
        Print("CANDLES: ", bullish, " bullish out of ", count, " (", timeframe, ")");
        lastCandleLog = TimeCurrent();
    }
    return bullish;
}

//+------------------------------------------------------------------+
//| Count bearish candles in last N candles                             |
//+------------------------------------------------------------------+
int CountBearishCandles(int count, ENUM_TIMEFRAMES timeframe = PERIOD_M1)
{
    int bearish = 0;
    for (int i = 0; i < count; i++)
    {
        int shift = i + 1;
        double open = iOpen(activeSymbol, timeframe, shift);
        double close = iClose(activeSymbol, timeframe, shift);
        if (close < open)
            bearish++;
    }
    return bearish;
}

//+------------------------------------------------------------------+
//| Check if all N candles are in the given direction                  |
//+------------------------------------------------------------------+
bool AreAllCandlesInDirection(string direction, int count, ENUM_TIMEFRAMES timeframe = PERIOD_M1)
{
    for (int i = 0; i < count; i++)
    {
        int shift = i + 1;
        double open = iOpen(activeSymbol, timeframe, shift);
        double close = iClose(activeSymbol, timeframe, shift);

        bool isBullish = (close > open);

        if (direction == "buy" && !isBullish)
            return false;  // Need bullish but got bearish
        if (direction == "sell" && isBullish)
            return false;  // Need bearish but got bullish
    }
    return true;
}

//+------------------------------------------------------------------+
//| Check if trend is confirmed by candles                              |
//+------------------------------------------------------------------+
bool IsTrendConfirmedByCandles(string direction, int count)
{
    if (RequireConsecutiveCandles)
    {
        return AreAllCandlesInDirection(direction, count, PERIOD_CURRENT);
    }
    else
    {
        // Majority mode: more than 50% must be in direction
        int required = (count / 2) + 1;
        int matching = (direction == "buy") ? CountBullishCandles(count, PERIOD_CURRENT)
                                               : CountBearishCandles(count, PERIOD_CURRENT);
        return (matching >= required);
    }
}

//+------------------------------------------------------------------+
//| Check if candles are going AGAINST current position                |
//+------------------------------------------------------------------+
bool AreCandlesAgainstPosition(int count)
{
    if (currentDirection == "")
        return false;

    string oppositeDirection = (currentDirection == "buy") ? "sell" : "buy";
    return IsTrendConfirmedByCandles(oppositeDirection, count);
}

//+------------------------------------------------------------------+
//| Check if should reverse direction                                  |
//+------------------------------------------------------------------+
bool ShouldReverseDirection(string newSignalDirection)
{
    Print("ShouldReverseDirection: new=", newSignalDirection, " current=", currentDirection);

    // Must be opposite direction
    if (newSignalDirection == currentDirection)
    {
        Print("BLOCK: Same direction");
        return false;
    }

    // Check if auto reverse is enabled
    if (!EnableAutoReverse)
    {
        Print("BLOCK: AutoReverse disabled");
        return false;
    }

    double accountProfit = AccountInfoDouble(ACCOUNT_PROFIT);
    Print("CHECK: Account Profit=$", accountProfit, " MinProfitToReverse=$", MinProfitToReverse);

    // Must have minimum profit (account TOTAL profit, not per position)
    if (accountProfit < MinProfitToReverse)
    {
        Print("BLOCK: Account Profit $", accountProfit, " < MinProfitToReverse $", MinProfitToReverse);
        return false;
    }

    // CRITICAL: Check if ALL positions are profitable before closing
    // If ANY position is negative, DO NOT CLOSE - use hedge instead
    int losingPositions = 0;
    int totalPositions = 0;
    double totalUnrealizedPL = 0;

    for (int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if (positionInfo.SelectByIndex(i))
        {
            if (positionInfo.Symbol() == activeSymbol &&
                positionInfo.Magic() == MagicNumber)
            {
                totalPositions++;
                double profit = positionInfo.Profit();
                totalUnrealizedPL += profit;
                if (profit < 0)
                {
                    losingPositions++;
                }
            }
        }
    }

    Print("POSITIONS CHECK: Total=", totalPositions, " Losing=", losingPositions, " P&L=$", totalUnrealizedPL);

    // If ANY position is losing, DON'T CLOSE - use hedge mode instead
    if (losingPositions > 0)
    {
        Print("BLOCK: Has ", losingPositions, " losing positions - Use HEDGE MODE");
        Print("Total P&L: $", totalUnrealizedPL, " - Will use HEDGE MODE instead of closing");
        return false;  // Force hedge mode to be used
    }

    Print("=== REVERSAL TRIGGERED ===");
    Print("- All ", totalPositions, " positions are profitable");
    Print("- Account Profit: $", accountProfit, " >= MinProfit: $", MinProfitToReverse);
    Print("- New signal direction: ", newSignalDirection, " (opposite of ", currentDirection, ")");
    Print("- Will close ALL positions and reverse direction");

    return true;
}

//+------------------------------------------------------------------+
//| Check if current positions are profitable                          |
//+------------------------------------------------------------------+
bool AreCurrentPositionsProfitable()
{
    int profitableCount = 0;
    int totalCount = 0;

    for (int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if (positionInfo.SelectByIndex(i))
        {
            if (positionInfo.Symbol() == activeSymbol &&
                positionInfo.Magic() == MagicNumber)
            {
                totalCount++;
                if (positionInfo.Profit() > 0)
                    profitableCount++;
            }
        }
    }

    // Consider profitable if at least half are in profit
    return (totalCount > 0 && profitableCount >= totalCount / 2);
}

//+------------------------------------------------------------------+
//| Execute grid order                                                |
//+------------------------------------------------------------------+
bool ExecuteGridOrder(string direction)
{
    Print("DEBUG ExecuteGridOrder: direction=", direction, " level=", currentGridLevel);

    // Normalize direction to lowercase
    direction = StringToLower(direction);
    Print("DEBUG: Normalized direction: ", direction);

    // CRITICAL: Validate direction before executing
    if (direction != "buy" && direction != "sell")
    {
        Print("ERROR: Invalid direction '", direction, "' - must be 'buy' or 'sell'");
        return false;
    }

    double volume = CalculateVolume();
    Print("DEBUG CalculateVolume result: ", volume);

    if (volume <= 0)
    {
        Print("ERROR: Invalid volume calculated: ", volume);
        return false;
    }

    // CRITICAL: Refresh symbol rates and verify they're valid
    if (!symbolInfo.RefreshRates())
    {
        Print("ERROR: Failed to refresh symbol rates for ", activeSymbol);
        return false;
    }

    double ask = symbolInfo.Ask();
    double bid = symbolInfo.Bid();

    // Verify prices are valid
    if (ask <= 0 || bid <= 0)
    {
        Print("ERROR: Invalid prices - Ask=", ask, " Bid=", bid, " Symbol=", activeSymbol);
        Print("ERROR: symbolInfo may not be properly initialized!");
        return false;
    }

    Print("DEBUG symbolInfo refreshed: Ask=", ask, " Bid=", bid);

    bool success = false;

    if (direction == "buy")
    {
        Print(">>> EXECUTING BUY ORDER <<<");

        double sl = StopLossPoints > 0 ? NormalizeDouble(ask - StopLossPoints * symbolInfo.Point(), symbolInfo.Digits()) : 0;
        double tp = TakeProfitPoints > 0 ? NormalizeDouble(ask + TakeProfitPoints * symbolInfo.Point(), symbolInfo.Digits()) : 0;

        Print("DEBUG: Attempting BUY - Ask=", ask, " SL=", sl, " TP=", tp, " Volume=", volume);

        if (trade.Buy(volume, activeSymbol, ask, sl, tp, "TVGrid"))
        {
            Print("BUY ORDER OPENED: Volume=", volume, " Price=", ask, " SL=", sl, " TP=", tp);
            success = true;
        }
        else
        {
            uint error = trade.ResultRetcode();
            Print("BUY ORDER FAILED. Error code: ", error, " Description: ", trade.ResultRetcodeDescription());
        }
    }
    else if (direction == "sell")
    {
        Print(">>> EXECUTING SELL ORDER <<<");

        double bid = symbolInfo.Bid();
        double sl = StopLossPoints > 0 ? NormalizeDouble(bid + StopLossPoints * symbolInfo.Point(), symbolInfo.Digits()) : 0;
        double tp = TakeProfitPoints > 0 ? NormalizeDouble(bid - TakeProfitPoints * symbolInfo.Point(), symbolInfo.Digits()) : 0;

        Print("DEBUG: Attempting SELL - Bid=", bid, " SL=", sl, " TP=", tp, " Volume=", volume);

        if (trade.Sell(volume, activeSymbol, bid, sl, tp, "TVGrid"))
        {
            Print("SELL ORDER OPENED: Volume=", volume, " Price=", bid, " SL=", sl, " TP=", tp);
            success = true;
        }
        else
        {
            Print("SELL ORDER FAILED: ", trade.ResultRetcodeDescription());
        }
    }

    if (success)
    {
        lastGridOrderTime = TimeCurrent();
        currentGridLevel++;

        // In hedge mode, also track new direction level separately
        if (inHedgeMode)
        {
            hedgeNewLevel++;
            Print("HEDGE: New level=", hedgeNewLevel, " Total level=", currentGridLevel);
        }

        totalOrdersOpened++;
    }

    return success;
}

//+------------------------------------------------------------------+
//| Calculate volume for trade                                          |
//+------------------------------------------------------------------+
double CalculateVolume()
{
    double volume;

    if (UseFixedLots)
    {
        volume = FixedLotSize;
        Print("CALCVOLUME: Using fixed lots = ", volume);
    }
    else
    {
        double equity = AccountInfoDouble(ACCOUNT_EQUITY);
        double riskAmount = equity * (RiskPercent / 100.0);

        double tickValue = SymbolInfoDouble(activeSymbol, SYMBOL_TRADE_TICK_VALUE);
        double slValue = StopLossPoints * tickValue;

        Print("CALCVOLUME: Equity=$", equity, " Risk=", RiskPercent, "% RiskAmount=$", riskAmount);
        Print("CALCVOLUME: TickValue=", tickValue, " StopLossPoints=", StopLossPoints, " slValue=", slValue);

        if (slValue > 0 && tickValue > 0)
        {
            volume = riskAmount / slValue;
            Print("CALCVOLUME: Calculated volume = ", volume);
        }
        else
        {
            volume = 0.01; // Default
            Print("CALCVOLUME: Using default volume (slValue or tickValue invalid)");
        }
    }

    // Validate lot size
    if (ValidateLotSize)
    {
        double minLot = SymbolInfoDouble(activeSymbol, SYMBOL_VOLUME_MIN);
        double maxLot = SymbolInfoDouble(activeSymbol, SYMBOL_VOLUME_MAX);
        double lotStep = SymbolInfoDouble(activeSymbol, SYMBOL_VOLUME_STEP);

        volume = MathFloor(volume / lotStep) * lotStep;
        volume = MathMax(minLot, MathMin(maxLot, volume));
    }

    // CRITICAL: Check for NaN or invalid volume
    if (volume <= 0 || volume != volume)  // NaN check: NaN != NaN
    {
        Print("ERROR: Invalid volume after calculation: ", volume, " - Using default 0.01");
        volume = 0.01;
    }

    Print("CALCVOLUME: Final volume = ", volume);
    return volume;
}

//+------------------------------------------------------------------+
//| Close all positions                                                |
//+------------------------------------------------------------------+
bool CloseAllPositions()
{
    int closedCount = 0;

    for (int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if (positionInfo.SelectByIndex(i))
        {
            if (positionInfo.Symbol() == activeSymbol &&
                positionInfo.Magic() == MagicNumber)
            {
                ulong ticket = positionInfo.Ticket();
                if (trade.PositionClose(ticket))
                {
                    closedCount++;
                }
                else
                {
                    Print("FAILED to close position ", ticket, ": ", trade.ResultRetcodeDescription());
                }
            }
        }
    }

    return (closedCount > 0);
}

//+------------------------------------------------------------------+
//| Check stop loss for individual positions                            |
//+------------------------------------------------------------------+
void CheckStopLoss()
{
    for (int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if (positionInfo.SelectByIndex(i))
        {
            if (positionInfo.Symbol() == activeSymbol &&
                positionInfo.Magic() == MagicNumber)
            {
                double profit = positionInfo.Profit();

                // Check if loss exceeds limit
                if (profit < -MaxLossPerOrder)
                {
                    Print("STOP LOSS TRIGGERED: Position ", positionInfo.Ticket(),
                          " Loss: $", profit, " Max: $", -MaxLossPerOrder);

                    trade.PositionClose(positionInfo.Ticket());
                }
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Manage trailing stop for profitable positions                     |
//+------------------------------------------------------------------+
void ManageTrailingStop()
{
    if (!EnableTrailingStop)
        return;

    for (int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if (positionInfo.SelectByIndex(i))
        {
            if (positionInfo.Symbol() == activeSymbol &&
                positionInfo.Magic() == MagicNumber)
            {
                ulong ticket = positionInfo.Ticket();
                double openPrice = positionInfo.PriceOpen();
                double currentSL = positionInfo.StopLoss();
                double point = symbolInfo.Point();
                int digits = symbolInfo.Digits();

                // Get current price
                symbolInfo.RefreshRates();

                if (positionInfo.PositionType() == POSITION_TYPE_BUY)
                {
                    double bid = symbolInfo.Bid();
                    double profitPoints = (bid - openPrice) / point;

                    // Only trail if profitable enough
                    if (profitPoints >= TrailingStartPoints)
                    {
                        double newSL = NormalizeDouble(bid - TrailingStopPoints * point, digits);

                        // Only move SL if it's better than current SL by at least TrailingStep
                        if (currentSL == 0 || (newSL - currentSL) / point >= TrailingStepPoints)
                        {
                            if (currentSL == 0 || newSL > currentSL)
                            {
                                trade.PositionModify(ticket, newSL, positionInfo.TakeProfit());
                                Print("TRAILING STOP (BUY): Ticket=", ticket,
                                      " OldSL=", currentSL, " NewSL=", newSL,
                                      " Bid=", bid, " Profit=", profitPoints, " points");
                            }
                        }
                    }
                }
                else if (positionInfo.PositionType() == POSITION_TYPE_SELL)
                {
                    double ask = symbolInfo.Ask();
                    double profitPoints = (openPrice - ask) / point;

                    // Only trail if profitable enough
                    if (profitPoints >= TrailingStartPoints)
                    {
                        double newSL = NormalizeDouble(ask + TrailingStopPoints * point, digits);

                        // Only move SL if it's better (lower) than current SL by at least TrailingStep
                        if (currentSL == 0 || (currentSL - newSL) / point >= TrailingStepPoints)
                        {
                            if (currentSL == 0 || newSL < currentSL)
                            {
                                trade.PositionModify(ticket, newSL, positionInfo.TakeProfit());
                                Print("TRAILING STOP (SELL): Ticket=", ticket,
                                      " OldSL=", currentSL, " NewSL=", newSL,
                                      " Ask=", ask, " Profit=", profitPoints, " points");
                            }
                        }
                    }
                }
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Reset grid state                                                   |
//+------------------------------------------------------------------+
void ResetGridState()
{
    currentDirection = "";
    lastGridOrderTime = 0;
    currentGridLevel = 0;
    targetReached = false;
    lastProcessedJson = "";
    lastSignalProcessedTime = 0;  // Reset signal cooldown timer

    // Reset hedge state
    inHedgeMode = false;
    hedgeOldDirection = "";
    hedgeStartTime = 0;
    hedgeNewLevel = 0;
}
//+------------------------------------------------------------------+
